package mastering;

import java.sql.Date;
import java.util.List;

import javax.ejb.EJB;
import javax.ejb.LocalBean;
import javax.ejb.Schedule;
import javax.ejb.Stateless;

import ejbholidaybookingapp.HolidayRemainingAppBeanRemote;
import ejbholidaybookingapp.HolidaySystemAppBeanRemote;
import ejbholidaybookingutilsapp.HolidayUtilsClass;
import entityclasses.EmployeeDTO;
import entityclasses.HolidayRemainingDTO;
import entityclasses.HolidayRequestDTO;
import model.THolidayRequest;

@Stateless
@LocalBean
public class Timer {

	@EJB
	private HolidaySystemAppBeanRemote holidaySystemAppBean;

	@EJB
	private HolidayRemainingAppBeanRemote holidayRemainingAppBean;

	public Timer() {
	}

	/* https://stackoverflow.com/questions/16059564/ejb-3-1-timer-to-schedule-1st-of-every-month
	 * Answered by Piotr Nowicki */
	@Schedule(dayOfMonth="15", hour="23", minute="48", persistent=false)
	public void runOncePerMonthForOneYearCheckingEmployees() {
		try {
			java.util.Date currentUtilDate = new java.util.Date();
			Date currentDate = new Date(currentUtilDate.getTime());
	
			List<HolidayRemainingDTO> holRemainingRecords = holidayRemainingAppBean.getAllHolidayRemaining();
			for (HolidayRemainingDTO e : holRemainingRecords) {
				if (currentDate.compareTo(e.getOneYearDateCheck()) > 0) {
					// update the holiday remaining days to the value from the employee table
					EmployeeDTO employee = holidaySystemAppBean.getEmployeeById(e.getIdEmp());
					HolidayRemainingDTO holRemaining = holidayRemainingAppBean.getHolidayRemainingById(e.getIdHolRemaining());
					
					holRemaining.setHolidayDaysRemaining(employee.getHolDaysEntitlement());
					holRemaining.setOneYearDateCheck(HolidayUtilsClass.addingOneYearToHireDate(e.getOneYearDateCheck()));
	
					holidayRemainingAppBean.updateHolRemainingRecord(holRemaining);
				}
			}

			System.out.println("One Year Cheched without errors...");
		} catch (Exception e) {
		}
	}

	/* https://stackoverflow.com/questions/16059564/ejb-3-1-timer-to-schedule-1st-of-every-month
	 * Answered by Piotr Nowicki */
	@Schedule(dayOfMonth="1", hour="2")
	public void runOncePerYearForFiveYearsCheckingEmployees() {
		java.util.Date currentUtilDate = new java.util.Date();
		Date currentDate = new Date(currentUtilDate.getTime());

		List<HolidayRemainingDTO> holRemainingRecords = holidayRemainingAppBean.getAllHolidayRemaining();
		for (HolidayRemainingDTO e : holRemainingRecords) {
			if (currentDate.compareTo(e.getOneYearDateCheck()) > 0) {
				// update the holiday remaining days to the value from the employee table
				EmployeeDTO employee = holidaySystemAppBean.getEmployeeById(e.getIdEmp());
				HolidayRemainingDTO holRemaining = holidayRemainingAppBean.getHolidayRemainingById(e.getIdHolRemaining());
				
				holRemaining.setHolidayDaysRemaining(employee.getHolDaysEntitlement());
				holRemaining.setOneYearDateCheck(HolidayUtilsClass.addingOneYearToHireDate(e.getOneYearDateCheck()));

				holidayRemainingAppBean.updateHolRemainingRecord(holRemaining);
			}
		}

/*
		15 April 2020 - 15 April 2021
		15 April 2021 - 15 April 2022
		15 April 2022 - 15 April 2023
		15 April 2023 - 15 April 2024
		15 April 2024 - 15 April 2025

		daca data curenta e mai mare decat de 15 April 2025 (hire date * 5) atunci se activeaza mecanismul
		si crestem cu o zi zilele de vacanta..
*/

		System.out.println(currentDate);
	}

}
